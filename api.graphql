### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AuthPayload {
  accessToken: String
}

"""Use JavaScript Date object for date/time fields."""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input DeckCreateManyWithoutAuthorInput {
  connect: [DeckWhereUniqueInput!]
  create: [DeckCreateWithoutAuthorInput!]
}

input DeckCreateManyWithoutUserInput {
  connect: [DeckWhereUniqueInput!]
  create: [DeckCreateWithoutUserInput!]
}

input DeckCreateWithoutAuthorInput {
  id: String
  logo: String!
  name: String!
  published: String!
  Template: TemplateCreateManyWithoutDeckInput
  url: String!
  User: UserCreateOneWithoutDecksInput
}

input DeckCreateWithoutUserInput {
  author: UserCreateOneWithoutDeckInput!
  id: String
  logo: String!
  name: String!
  published: String!
  Template: TemplateCreateManyWithoutDeckInput
  url: String!
}

input DeckFilter {
  every: DeckWhereInput
  none: DeckWhereInput
  some: DeckWhereInput
}

input DeckScalarWhereInput {
  AND: [DeckScalarWhereInput!]
  authorId: StringFilter
  id: StringFilter
  logo: StringFilter
  name: StringFilter
  NOT: [DeckScalarWhereInput!]
  OR: [DeckScalarWhereInput!]
  published: StringFilter
  Template: TemplateFilter
  url: StringFilter
  userId: NullableStringFilter
}

input DeckUpdateManyDataInput {
  id: String
  logo: String
  name: String
  published: String
  url: String
}

input DeckUpdateManyWithoutAuthorInput {
  connect: [DeckWhereUniqueInput!]
  create: [DeckCreateWithoutAuthorInput!]
  delete: [DeckWhereUniqueInput!]
  deleteMany: [DeckScalarWhereInput!]
  disconnect: [DeckWhereUniqueInput!]
  set: [DeckWhereUniqueInput!]
  update: [DeckUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [DeckUpdateManyWithWhereNestedInput!]
  upsert: [DeckUpsertWithWhereUniqueWithoutAuthorInput!]
}

input DeckUpdateManyWithoutUserInput {
  connect: [DeckWhereUniqueInput!]
  create: [DeckCreateWithoutUserInput!]
  delete: [DeckWhereUniqueInput!]
  deleteMany: [DeckScalarWhereInput!]
  disconnect: [DeckWhereUniqueInput!]
  set: [DeckWhereUniqueInput!]
  update: [DeckUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [DeckUpdateManyWithWhereNestedInput!]
  upsert: [DeckUpsertWithWhereUniqueWithoutUserInput!]
}

input DeckUpdateManyWithWhereNestedInput {
  data: DeckUpdateManyDataInput!
  where: DeckScalarWhereInput!
}

input DeckUpdateWithoutAuthorDataInput {
  id: String
  logo: String
  name: String
  published: String
  Template: TemplateUpdateManyWithoutDeckInput
  url: String
  User: UserUpdateOneWithoutDecksInput
}

input DeckUpdateWithoutUserDataInput {
  author: UserUpdateOneRequiredWithoutDeckInput
  id: String
  logo: String
  name: String
  published: String
  Template: TemplateUpdateManyWithoutDeckInput
  url: String
}

input DeckUpdateWithWhereUniqueWithoutAuthorInput {
  data: DeckUpdateWithoutAuthorDataInput!
  where: DeckWhereUniqueInput!
}

input DeckUpdateWithWhereUniqueWithoutUserInput {
  data: DeckUpdateWithoutUserDataInput!
  where: DeckWhereUniqueInput!
}

input DeckUpsertWithWhereUniqueWithoutAuthorInput {
  create: DeckCreateWithoutAuthorInput!
  update: DeckUpdateWithoutAuthorDataInput!
  where: DeckWhereUniqueInput!
}

input DeckUpsertWithWhereUniqueWithoutUserInput {
  create: DeckCreateWithoutUserInput!
  update: DeckUpdateWithoutUserDataInput!
  where: DeckWhereUniqueInput!
}

input DeckWhereInput {
  AND: [DeckWhereInput!]
  author: UserWhereInput
  authorId: StringFilter
  id: StringFilter
  logo: StringFilter
  name: StringFilter
  NOT: [DeckWhereInput!]
  OR: [DeckWhereInput!]
  published: StringFilter
  Template: TemplateFilter
  url: StringFilter
  User: UserWhereInput
  userId: NullableStringFilter
}

input DeckWhereUniqueInput {
  id: String
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Mutation {
  createOneUser(data: UserCreateInput!): User!
  deleteOneUser(where: UserWhereUniqueInput!): User
  signIn(email: String!, password: String!): AuthPayload
  signUp(email: String!, firstName: String!, lastName: String!): String
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NullableDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Query {
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: UserOrderByInput, where: UserWhereInput): [User!]!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

input TemplateCreateManyWithoutDeckInput {
  connect: [TemplateWhereUniqueInput!]
  create: [TemplateCreateWithoutDeckInput!]
}

input TemplateCreateWithoutDeckInput {
  icon: String!
  id: String
  name: String!
}

input TemplateFilter {
  every: TemplateWhereInput
  none: TemplateWhereInput
  some: TemplateWhereInput
}

input TemplateScalarWhereInput {
  AND: [TemplateScalarWhereInput!]
  deckId: StringFilter
  icon: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [TemplateScalarWhereInput!]
  OR: [TemplateScalarWhereInput!]
}

input TemplateUpdateManyDataInput {
  icon: String
  id: String
  name: String
}

input TemplateUpdateManyWithoutDeckInput {
  connect: [TemplateWhereUniqueInput!]
  create: [TemplateCreateWithoutDeckInput!]
  delete: [TemplateWhereUniqueInput!]
  deleteMany: [TemplateScalarWhereInput!]
  disconnect: [TemplateWhereUniqueInput!]
  set: [TemplateWhereUniqueInput!]
  update: [TemplateUpdateWithWhereUniqueWithoutDeckInput!]
  updateMany: [TemplateUpdateManyWithWhereNestedInput!]
  upsert: [TemplateUpsertWithWhereUniqueWithoutDeckInput!]
}

input TemplateUpdateManyWithWhereNestedInput {
  data: TemplateUpdateManyDataInput!
  where: TemplateScalarWhereInput!
}

input TemplateUpdateWithoutDeckDataInput {
  icon: String
  id: String
  name: String
}

input TemplateUpdateWithWhereUniqueWithoutDeckInput {
  data: TemplateUpdateWithoutDeckDataInput!
  where: TemplateWhereUniqueInput!
}

input TemplateUpsertWithWhereUniqueWithoutDeckInput {
  create: TemplateCreateWithoutDeckInput!
  update: TemplateUpdateWithoutDeckDataInput!
  where: TemplateWhereUniqueInput!
}

input TemplateWhereInput {
  AND: [TemplateWhereInput!]
  deck: DeckWhereInput
  deckId: StringFilter
  icon: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [TemplateWhereInput!]
  OR: [TemplateWhereInput!]
}

input TemplateWhereUniqueInput {
  id: String
}

type User {
  email: String!
  firstName: String!
  id: String!
  invite: String
  lastName: String!
  password: String
  status: Int
  userType: String!
}

input UserCreateInput {
  createdAt: DateTime
  Deck: DeckCreateManyWithoutAuthorInput
  decks: DeckCreateManyWithoutUserInput
  deletedAt: DateTime
  email: String!
  firstName: String!
  id: String
  invite: String
  lastName: String!
  password: String
  status: Int
  userType: String!
}

input UserCreateOneWithoutDeckInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutDeckInput
}

input UserCreateOneWithoutDecksInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutDecksInput
}

input UserCreateWithoutDeckInput {
  createdAt: DateTime
  decks: DeckCreateManyWithoutUserInput
  deletedAt: DateTime
  email: String!
  firstName: String!
  id: String
  invite: String
  lastName: String!
  password: String
  status: Int
  userType: String!
}

input UserCreateWithoutDecksInput {
  createdAt: DateTime
  Deck: DeckCreateManyWithoutAuthorInput
  deletedAt: DateTime
  email: String!
  firstName: String!
  id: String
  invite: String
  lastName: String!
  password: String
  status: Int
  userType: String!
}

input UserOrderByInput {
  createdAt: OrderByArg
  deletedAt: OrderByArg
  email: OrderByArg
  firstName: OrderByArg
  id: OrderByArg
  invite: OrderByArg
  lastName: OrderByArg
  password: OrderByArg
  status: OrderByArg
  userType: OrderByArg
}

input UserUpdateInput {
  createdAt: DateTime
  Deck: DeckUpdateManyWithoutAuthorInput
  decks: DeckUpdateManyWithoutUserInput
  deletedAt: DateTime
  email: String
  firstName: String
  id: String
  invite: String
  lastName: String
  password: String
  status: Int
  userType: String
}

input UserUpdateOneRequiredWithoutDeckInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutDeckInput
  update: UserUpdateWithoutDeckDataInput
  upsert: UserUpsertWithoutDeckInput
}

input UserUpdateOneWithoutDecksInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutDecksInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutDecksDataInput
  upsert: UserUpsertWithoutDecksInput
}

input UserUpdateWithoutDeckDataInput {
  createdAt: DateTime
  decks: DeckUpdateManyWithoutUserInput
  deletedAt: DateTime
  email: String
  firstName: String
  id: String
  invite: String
  lastName: String
  password: String
  status: Int
  userType: String
}

input UserUpdateWithoutDecksDataInput {
  createdAt: DateTime
  Deck: DeckUpdateManyWithoutAuthorInput
  deletedAt: DateTime
  email: String
  firstName: String
  id: String
  invite: String
  lastName: String
  password: String
  status: Int
  userType: String
}

input UserUpsertWithoutDeckInput {
  create: UserCreateWithoutDeckInput!
  update: UserUpdateWithoutDeckDataInput!
}

input UserUpsertWithoutDecksInput {
  create: UserCreateWithoutDecksInput!
  update: UserUpdateWithoutDecksDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  Deck: DeckFilter
  decks: DeckFilter
  deletedAt: NullableDateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  invite: NullableStringFilter
  lastName: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: NullableStringFilter
  status: NullableIntFilter
  userType: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}
